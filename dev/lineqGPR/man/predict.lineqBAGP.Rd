% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lineqBAGP.R
\name{predict.lineqBAGP}
\alias{predict.lineqBAGP}
\title{Prediction Method for the \code{"lineqBAGP"} S3 Class}
\usage{
\method{predict}{lineqBAGP}(object, xtest, return_model = FALSE, ...)
}
\arguments{
\item{object}{an object with class \code{"lineqBAGP"}.}

\item{xtest}{a vector (or matrix) with the test input design}

\item{return_model}{If \code{TRUE}, the augmented model is returned (see \code{\link{augment.lineqBAGP}}).}

\item{...}{further arguments passed to or from other methods}
}
\value{
A \code{"lineqBAGP"} object with the following elements.
\item{Lambda}{a matrix corresponding to the linear set of inequality constraints}
\item{lb}{the lower bound vector of the inequalities constraints}
\item{ub}{the upper bound vector of the inequalities constraints}
\item{Phi.test}{a matrix corresponding to the hat basis functions evaluated
at \code{xtest}. The basis functions are indexed by rows}
\item{mu}{the unconstrained GP mean predictor}
\item{Sigma}{the unconstrained GP prediction conditional covariance matrix}
\item{xi.map}{the GP maximum a posteriori (MAP) predictor given the inequality constraints}
\item{Gamma}{ Matrix representing \eqn{k_{S}(\xi,\xi)}}
\item{Gamma.block}{ Gamma represented per block as a list of matrices}
\item{Phi}{ Matrix representing \eqn{\Phi}}
\item{Phi.block}{ Phi represented per block as a list of matrices}
\item{t_phi}{ The transpose of Phi}
\item{t_Phi.block}{ t_Phi represented per block as a list of matrices}
\item{invSigma}{ The covariance matrix of the gaussian vector }
\item{y.mean}{Prediction of x knowing that }
\item{mid.term}{ The mid term is computed}
\item{xi.mode}{Mode of the truncated Gaussian vector}
}
\description{
Prediction method for the \code{"lineqBAGP"} S3 class.
}
\details{
The posterior paramaters of the finite-dimensional GP with linear inequality
constraints are computed. Here, \eqn{\boldsymbol{\xi}}{\xi} is a centred Gaussian
vector with covariance \eqn{\boldsymbol{\Gamma}}{\Gamma}, s.t.
\eqn{\boldsymbol{\Phi} \boldsymbol{\xi} = \boldsymbol{y}}{\Phi \xi = y}
(interpolation constraints) and
\eqn{\boldsymbol{l} \leq \boldsymbol{\Lambda} \boldsymbol{\xi} \leq \boldsymbol{u}}{lb \le \Lambda \xi \le ub}
(inequality constraints).
}
\examples{

# synthetic data
d <- 3 # number of active input variables
partition <- list(c(1,3), 2) # partition of the block structure
nblocks <- length(partition) # nb of blocks

targetFun <- function(x, partition)
  return(x[, partition[[1]][1]]*x[, partition[[1]][2]] + x[, partition[[2]][1]])

# building a random design 
nbdesign <- 6*d
xdesign <- matrix(runif(nbdesign*d), nbdesign, d)
ydesign <- targetFun(xdesign, partition)

# defining the 3D grid for predictions 
n1D <- 20
xbase <- seq(0, 1, length = n1D)
xtest <- as.matrix(expand.grid(xbase, xbase, xbase))
ytest <- targetFun(xtest, partition)

# creating the model
model <- create(class = "lineqBAGP", x = xdesign, y = ydesign,
                constrType = rep("monotonicity", nblocks), 
                partition = partition,
                subdivision_size = list(c(3, 5), 2))

# modifying the covariance parameters of each block
for (k in 1:nblocks)
  model$kernParam$par[[k]] <- c(1, rep(0.1, model$localParam$dim_block[k]))

# computing the unconstrained GP mean and the constrained GP mode
pred <- predict(model, xtest)

# Q2 criterion
var_design <- mean((ytest- mean(ytest))^2)
message("Unconstrained GP mean: ", 1 - mean((ytest- pred$y.mean)^2)/var_design)
message("Constrained GP mode: ", 1 - mean((ytest- pred$y.mode)^2)/var_design)

}
\references{
A. F. Lopez-Lopera (2019),
"Gaussian process modelling under inequality constraints".
\emph{PhD thesis, Mines Saint-Etienne}
<https://tel.archives-ouvertes.fr/tel-02863891>
}
\seealso{
\code{\link{create.lineqBAGP}}, \code{\link{augment.lineqBAGP}},
         \code{\link{simulate.lineqBAGP}}
}
\author{
M. Deronzier and A. F. Lopez-Lopera
}
