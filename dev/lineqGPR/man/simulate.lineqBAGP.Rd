% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lineqBAGP.R
\name{simulate.lineqBAGP}
\alias{simulate.lineqBAGP}
\title{Simulation Method for the \code{"lineqBAGP"} S3 Class}
\usage{
\method{simulate}{lineqBAGP}(object, nsim = 1, seed = NULL, xtest, ...)
}
\arguments{
\item{object}{an object with class \code{"lineqBAGP"}}

\item{nsim}{the number of simulations}

\item{seed}{see \code{\link{simulate}}}

\item{xtest}{a vector (or matrix) with the test input design}

\item{...}{further arguments passed to or from other methods}
}
\value{
A \code{"lineqBAGP"} object with the following elements
\item{x}{a vector (or matrix) with the training input design}
\item{y}{the training output vector at \code{x}}
\item{xtest}{a vector (or matrix) with the test input design}
\item{Phi.test}{a matrix corresponding to the hat basis functions evaluated
at \code{xtest}. The basis functions are indexed by rows.}
\item{xi.sim}{the posterior sample-path of the finite-dimensional Gaussian vector}
\item{ysim}{the posterior sample-path of the observed GP
Note: \code{ysim = Phi.test \%*\% xi.sim}}
}
\description{
Simulation method for the \code{"lineqBAGP"} S3 class.
}
\details{
The posterior sample-path of the finite-dimensional GP with linear inequality
constraints are computed. Here, \eqn{\boldsymbol{\xi}}{\xi} is a centred Gaussian
vector with covariance \eqn{\boldsymbol{\Gamma}}{\Gamma}, s.t.
\eqn{\boldsymbol{\Phi} \boldsymbol{\xi} = \boldsymbol{y}}{\Phi \xi = y}
(interpolation constraints) and
\eqn{\boldsymbol{l} \leq \boldsymbol{\Lambda} \boldsymbol{\xi} \leq \boldsymbol{u}}{lb \le \Lambda \xi \le ub}
(inequality constraints).
}
\examples{

# synthetic data
d <- 3 # number of active input variables
partition <- list(c(1,3), 2) # partition of the block structure
nblocks <- length(partition) # nb of blocks

targetFun <- function(x, partition)
  return(x[, partition[[1]][1]]*x[, partition[[1]][2]] + x[, partition[[2]][1]])

# building a random design 
nbdesign <- 6*d
xdesign <- matrix(runif(nbdesign*d), nbdesign, d)
ydesign <- targetFun(xdesign, partition)

# defining the 3D grid for predictions 
n1D <- 20
xbase <- seq(0, 1, length = n1D)
xtest <- as.matrix(expand.grid(xbase, xbase, xbase))
ytest <- targetFun(xtest, partition)

# creating the model
model <- create(class = "lineqBAGP", x = xdesign, y = ydesign,
                constrType = rep("monotonicity", nblocks), 
                partition = partition,
                m = c(5, 3, 4))

# modifying the covariance parameters of each block
for (k in 1:nblocks)
  model$kernParam$par[[k]] <- c(1, rep(0.1, model$localParam$dim_block[k]))
  
# simulating constrained MCMC samples
model.sim <- simulate(model, 1e2, seed = 1, xtest)

# Q2 criterion
var_design <- mean((ytest- mean(ytest))^2)
message("Unconstrained GP mean: ", 1 - mean((ytest- model.sim$y.mean)^2)/var_design)
message("Constrained GP mode: ", 1 - mean((ytest- model.sim$y.mode)^2)/var_design)
message("Constrained GP mean via MCMC: ", 1 - mean((ytest- rowMeans(model.sim$y.sim))^2)/var_design)

}
\references{
A. F. Lopez-Lopera (2019),
"Gaussian process modelling under inequality constraints".
\emph{PhD thesis, Mines Saint-Etienne}
<https://tel.archives-ouvertes.fr/tel-02863891>
}
\seealso{
\code{\link{create.lineqBAGP}}, \code{\link{augment.lineqBAGP}},
         \code{\link{predict.lineqBAGP}}
}
\author{
M. Deronzier and A. F. Lopez-Lopera
}
